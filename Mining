; Configuration
set %runebookId PIWYJMD          ; Runebook ID (first rune = drop location, 2-16th runes = mines)
set %dropContainerId XWNAKMD     ; Work container (drop ingots/ores, contains recall scroll, contains pickaxes)
set %smeltWeight 350             ; Weight needed to go smelt
set %bankWeight 175              ; Weight needed after smelting to go bank
set %smelt1x1 #false             ; Smelt ores one by one (#true/#false)
set %miningToolsRecharge 4       ; Amount of mining tools to have before going back mining (1 if you got newbied pickaxe)
set %mines 15                    ; Number of mines in runebook (slot 2-16)
set %rechargeRunebook #true      ; Recharge runebook (#true/#false)
set %maxRunebookCharges 10       ; Maximum charges in runebook
set %miningToolsToCraft 10       ; When out of pickaxes, amount to craft
set %mineArea 40                 ; Area to scan for minable tiles around forge
set %maximumPathfindDistance 19  ; Maximum distance to pathFind
set %smartPathFindTimeout 60     ; Maximum time allowed per smart pathfind (seconds)
set %pathfindTimeout 10          ; Maximum time allowed per pathfind (seconds)
set %miningTimeout 8             ; Maximum time allowed per mining stroke (seconds)
set %nodeMaximumTries 3          ; Maximum failed attempts per mining node before going to the next

; Constants
set %tinkeringTools GTL
set %ironRequiredMiningTool 8
set %miningTools NPF_QPF
set %forge JBG
set %oresStacks DWJ_EWJ_GWJ
set %oresOne TVJ
set %ores %oresStacks , _ , %oresOne
set %ironIngots RMK
set %ingots %ironIngots , _NMK_XMK_TMK
set %oresIngots %ores , _ , %ingots
set %recallScrolls WTL
set %pathFindMineSpotTolerance 0
set %pathFindForgeTolerance 1

; Stats
set %ironCollected 0
set %stoneCollected 0
set %miningToolsUsed 0
set %recallScrollsUsed 0

; Do not change
set %mustBank #false
set %currentMine 1
set %start #scnt

set #LPC 1000
tile init

miningLoop:
set %mustBank #false
gosub resetForge
gosub resetSpots
for %miningLoop 1 %spots
{
    gosub updateTitle

    set %mineX %spotX . %miningLoop
    set %mineY %spotY . %miningLoop
    set %mineZ %spotZ . %miningLoop

    gosub hasUnminedTileAround %mineX %mineY
    if ( #result = #true )
    {
        gosub smartPathFind %mineX %mineY %mineZ %pathFindMineSpotTolerance
        if ( #result = #true )
        {
            set %_startX %mineX - 1
            set %_startY %mineY - 1
            set %_endX %mineX + 1
            set %_endY %mineY + 1
            
            for %_loopX %_startX %_endX
            {
                for %_loopY %_startY %_endY
                {
                    if ( %_loopX = %mineX && %_loopY = %mineY )
                        continue

                    gosub isLocationMineable %_loopX %_loopY
                    if ( #result = #true )
                    {
                        set %_mineLocation %1 , _ , %2
                        set %_mineLocationTileType %spotTileType . %_mineLocation
                        set %_mineLocationZ %spotZ . %_mineLocation

                        gosub mine %_loopX %_loopY %_mineLocationZ %_mineLocationTileType
                        
                        set %spotMined . %_mineLocation #true
                    }

                    if ( %mustBank = #true )
                        goto skipMine
                }
            }
        }
    }
}
skipMine:
gosub smartPathFind %forgeX %forgeY %forgeZ %pathFindForgeTolerance
gosub smelt
gosub bank
wait 20
goto miningLoop

sub resetForge
findItem %forge G_3
if ( #findKind = -1 )
    pause
set %forgeX #findX
set %forgeY #findY
set %forgeZ #findZ
return

sub resetSpots
set %startX %forgeX - %mineArea
set %startY %forgeY - %mineArea
set %endX %forgeX + %mineArea
set %endY %forgeY + %mineArea
set %_startY %startY
set %_endY %endY
set %spots 0
for %_loopX %startX %endX
{
    for %_loopY %_startY %_endY
    {
        tile cnt %_loopX %_loopY
        set %_skipSpot #false
        
        for %tile 1 #tileCnt
        {
            tile get %_loopX %_loopY %tile

            if ( #tileName in stalagmites_flowstone_cave_wall )
                set %_skipSpot #true

            if ( ( #tileType >= 1339 && #tileType <= 1345 ) )
            {
                set %spots %spots + 1
                set %spotX . %spots %_loopX
                set %spotY . %spots %_loopY
                set %spotZ . %spots #tileZ
                set %spotMined . %_loopX , _ , %_loopY #false
                set %spotTileType . %_loopX , _ , %_loopY #tileType
                set %spotZ . %_loopX , _ , %_loopY #tileZ
            }
        }
        
        if ( %_skipSpot = #true )
            set %spots %spots - 1
    }
}
return

; gosub hasUnminedTileAround locationX locationY
sub hasUnminedTileAround
set %_hasUnminedTileAroundLocationX %1
set %_hasUnminedTileAroundLocationY %2
set %_hasUnminedTileAroundStartX %_hasUnminedTileAroundLocationX - 1
set %_hasUnminedTileAroundStartY %_hasUnminedTileAroundLocationY - 1
set %_hasUnminedTileAroundEndX %_hasUnminedTileAroundLocationX + 1
set %_hasUnminedTileAroundEndY %_hasUnminedTileAroundLocationY + 1

for %_hasUnminedTileAroundLoopX %_hasUnminedTileAroundStartX %_hasUnminedTileAroundEndX
{
    for %_hasUnminedTileAroundLoopY %_hasUnminedTileAroundStartY %_hasUnminedTileAroundEndY
    {
        if ( %_hasUnminedTileAroundLoopX = %_hasUnminedTileAroundLocationX && %_hasUnminedTileAroundLoopY = %_hasUnminedTileAroundLocationY )
            continue ; can't mine under yourself

        gosub isLocationMineable %_hasUnminedTileAroundLoopX %_hasUnminedTileAroundLoopY
        if ( #result = #true )
            return #true
    }
}
return #false

; gosub isLocationMineable x y
sub isLocationMineable
set %_isLocationMineableX_Y %1 , _ , %2
set %_isLocationMineableIsMined %spotMined . %_isLocationMineableX_Y
if ( %_isLocationMineableIsMined = #false )
    return #true
return #false ; this case handle N/A

; gosub smartPathFind [x] [y] [z] [tolerance]
sub smartPathFind
set %_smartPathFindX %1
set %_smartPathFindY %2
set %_smartPathFindZ %3
set %_smartPathFindTolerance %4
set %_smartPathFindTimeout #scnt + %smartPathFindTimeout
gosub isCharPosWithinTolerance %_smartPathFindX %_smartPathFindY %maximumPathfindDistance
while ( #result = #false )
{
    if ( %_smartPathFindTimeout < #scnt )
        break

    set %_bestCandidateX #charPosX
    set %_bestCandidateY #charPosY
    set %_bestCandidateZ #charPosZ

    for %_candidate 1 %spots
    {
        set %_candidateX %spotX . %_candidate
        set %_candidateY %spotY . %_candidate
        set %_candidateZ %spotZ . %_candidate

        gosub isBetterSmartPathFindCandidate %_candidateX %_candidateY %_smartPathFindX %_smartPathFindY %_bestCandidateX %_bestCandidateY %maximumPathfindDistance
        if ( #result = #true )
        {
            set %_bestCandidateX %_candidateX
            set %_bestCandidateY %_candidateY
            set %_bestCandidateZ %_candidateZ
        }
    }

    if ( %_bestCandidateX = #charPosX && %_bestCandidateY = #charPosY )
        return #false ; no candidate found

    gosub pathFind %_bestCandidateX %_bestCandidateY %_bestCandidateZ %_smartPathFindTolerance
    if ( #result = #false )
        return #false
    gosub isCharPosWithinTolerance %_smartPathFindX %_smartPathFindY %maximumPathfindDistance
}
gosub pathFind %_smartPathFindX %_smartPathFindY %_smartPathFindZ %_smartPathFindTolerance %_smartPathFindTimeout
return #result

; gosub isBetterSmartPathFindCandidate candidateX candidateY destinationX destinationY bestCandidateX bestCandidateY maxDistance
sub isBetterSmartPathFindCandidate
set %_distanceToCandidateX #charPosX - %1 abs
set %_distanceToCandidateY #charPosY - %2 abs

if ( %_distanceToCandidateX > %7 || %_distanceToCandidateY > %7 )
    return #false ; Candidate is out of reach

set %_distanceCandidateToDestinationX %1 - %3 abs
set %_distanceCandidateToDestinationY %2 - %4 abs
set %_distanceCandidateToDestination %_distanceCandidateToDestinationX + %_distanceCandidateToDestinationY

set %_distanceBestCandidateToDestinationX %5 - %3 abs
set %_distanceBestCandidateToDestinationY %6 - %4 abs
set %_distanceBestCandidateToDestination %_distanceBestCandidateToDestinationX + %_distanceBestCandidateToDestinationY

if ( %_distanceCandidateToDestination < %_distanceBestCandidateToDestination )
    return #true ; Candidate is in reach and nearer to wanted destination

return #false ; Candidate is in reach, but farer to wanted destination

; gosub pathfind [x] [y] [z] [tolerance]
sub pathfind
set %_pathFindX %1
set %_pathFindY %2
set %_pathFindZ %3
set %_pathFindTolerance %4
set %_pathfindMoved #false
set %_timeout #scnt + %pathfindTimeout
set %_journal #jIndex + 1
gosub isCharPosWithinTolerance %_pathFindX %_pathFindY %_pathFindTolerance
if ( #result = #true )
{
    if ( %_pathfindMoved = #true )
        event pathfind 0 0 0
    return #true
}
event pathfind %_pathFindX %_pathFindY %_pathFindZ
_pathfind:
gosub isCharPosWithinTolerance %_pathFindX %_pathFindY %_pathFindTolerance
if ( #result = #true )
{
    if ( %_pathfindMoved = #true )
        event pathfind 0 0 0
    return #true
}
if ( %_timeout < #scnt )
{
    if ( %_pathfindMoved = #true )
        event pathfind 0 0 0
    return #false
}
if ( %_journal <= #jIndex )
{
    scanJournal %_journal
    if ( get_there in #journal )
        return #false
    if ( pathfinding in #journal )
        set %_pathfindMoved #true
    set %_journal %_journal + 1
}
goto _pathfind

sub isCharPosWithinTolerance
set %_x %1
set %_y %2
set %_dist %3
set %_distX #charPosX - %_x abs
set %_distY #charPosY - %_y abs
if ( %_distX <= %_dist && %_distY <= %_dist )
    return #true
return #false

sub mine
set %_mineX %1
set %_mineY %2
set %_mineZ %3
set %_mineTile %4
set %_nodeTries 0
_mine:
set %_nodeTries %_nodeTries + 1
if ( %_nodeTries > %nodeMaximumTries )
    return
if ( #weight >= %smeltWeight )
{
    gosub smartPathFind %forgeX %forgeY %forgeZ %pathFindForgeTolerance
    gosub smelt
    wait 10

    if ( #weight >= %bankWeight )
    {
        set %mustBank #true

        return
    }
    gosub smartPathFind %_mineX %_mineY %_mineZ %pathFindMineSpotTolerance
}
findItem %miningTools C_
if ( #findKind = -1 )
{
    set %mustBank #true

    return
}
set #lObjectId #findId
set #lTargetX %_mineX
set #lTargetY %_mineY
set #lTargetZ %_mineZ
set #lTargetTile %_mineTile
set #lTargetKind 3
set %_journal #jIndex
event macro 17
target
event macro 22
set %_mine #scnt + %miningTimeout
_mineJournal:
if ( %_mine < #scnt )
    return
if ( #jIndex <= %_journal )
    goto _mineJournal
set %_journal %_journal + 1
scanJournal %_journal
if ( there_is_nothing_here in #journal )
    return
if ( you_loosen_some_rocks in #journal )
    goto _mine
if ( you_put in #journal )
{
    set %_nodeTries 0
    goto _mine
}
if ( you_cannot_mine in #journal )
    return
if ( you_have_no_line in #journal )
    return
if ( try_mining_elsewhere in #journal )
    return
if ( that_is_too_far in #journal )
    return
goto _mineJournal

sub smelt
if ( %smelt1x1 = #true )
    gosub separateOres
ignoreItem reset
_smelt:
findItem %ores C_ , #backPackId
if ( #findKind = -1 )
    return
set #lObjectId #findId
set %_journal #jIndex + 1
event macro 17
for %_loop %_journal #jIndex
{
    scanJournal %_loop
    if ( you_need_atleast in #journal )
        ignoreItem #findId
    if ( you_must_be_near in #journal )
        ignoreItem #findId
}
goto _smelt

sub separateOres
ignoreitem reset
_seperateOres:
finditem %oresStacks C_ , #backpackId
if ( #findKind = -1 )
    return
ignoreitem #findId
exevent drag #findId 1
wait 5
exevent dropc #backpackid 80 80
wait 5
goto _seperateOres

; gosub recall [rune]
sub recall
set %_rune %1
if ( %_rune <= 8 )
{
    set %_runeX 85
    set %_runeY 115 + ( ( %_rune - 1 ) * 14 )
}
else
{
    set %_runeX 245
    set %_runeY 115 + ( ( %_rune - 9 ) * 14 )
}
set %_charPosX #charPosX
set %_charPosY #charPosY
_openRunebook:
set %_openRunebook #scnt + 10
set #lObjectId %runebookId
event macro 17
_waitOpenRunebook:
if ( %_openRunebook < #scnt )
   goto _openRunebook
if ( #contSizeX <> 352 || #contSizeY <> 226 )
   goto _waitOpenRunebook
set %_recall #scnt + 10
click %_runeX %_runeY
_waitRecall:
if ( %_recall < #scnt )
    goto _openRunebook
if ( #charPosX <> %_charPosX || #charPosY <> %_charPosY )
    return
goto _waitRecall

sub bank
gosub recall 1
gosub dropIngotsOres
gosub restockMiningTools
if ( %rechargeRunebook = #true )
    gosub rechargeRunebook
set %currentMine %currentMine + 1
if ( %currentMine > %mines )
    set %currentMine 1
set %mineTemp %currentMine + 1
gosub recall %mineTemp
return

sub dropIngotsOres
ignoreitem reset
_dropIngotsOres:
findItem %oresIngots C_ , #backpackId
if ( #findKind = -1 )
    return
if ( #findType in %ingots && #findCol = 0 )
    set %ironCollected %ironCollected + #findStack
if ( #findType in %ingots && #findCol = 2103 )
    set %stoneCollected %stoneCollected + #findStack
ignoreitem #findid
exevent drag #findId #findStack
wait 10
exevent dropc %dropContainerId
wait 10
goto _dropIngotsOres

sub restockMiningTools
findItem %miningTools C_ , #backPackId
if ( #findCnt >= %miningToolsRecharge )
    return
set %miningToolsToGrab %miningToolsRecharge - #findCnt
gosub openContainer %dropContainerId
findItem %miningTools C_ , %dropContainerId
if ( #findCnt < %miningToolsToGrab )
    gosub craftMiningTools
for %_loop 1 %miningToolsToGrab
{
    findItem %miningTools C_ , %dropContainerId
    exevent drag #findId
    wait 10
    exevent dropC #backPackId
    wait 10
}
set %miningToolsUsed %miningToolsUsed + %miningToolsToGrab
return

sub craftMiningTools
findItem %tinkeringTools C_ , %dropContainerId
if ( #findKind = -1 )
    pause
exevent drag #findId 1
wait 10
exevent dropC #backPackId
wait 10
ignoreItem reset
_findIronIngots:
findItem %ironIngots C_ , %dropContainerId
if ( #findKind = -1 )
    pause
if ( #findCol <> 0 )
{
    ignoreItem #findId
    goto _findIronIngots
}
set %_ironAmount %ironRequiredMiningTool * %miningToolsToCraft
exevent drag #findId %_ironAmount
wait 10
exevent dropC #backPackId
wait 10
_craftMiningTool:
findItem %ingots C_ , #backPackId
if ( #findKind = -1 || #findStack < %ironRequiredMiningTool )
    goto _dropTinkeringTools
msg $,waitmenu 'Tinkering' 'Tools' 'Tools' 'pickaxe'$
findItem %tinkeringTools C_ , #backPackId
set #lObjectId #findId
event macro 17
wait 80
goto _craftMiningTool
_dropTinkeringTools:
findItem %tinkeringTools C_ , #backPackId
exevent drag #findId 1
wait 10
exevent dropC %dropContainerId
wait 10
_dropMiningTools:
findItem %miningTools C_ , #backPackId
if ( #findKind = -1 )
    return
exevent drag #findId 1
wait 10
exevent dropC %dropContainerId 50 50
wait 10
goto _dropMiningTools

sub rechargeRunebook
ignoreItem reset
gosub openContainer %dropContainerId
_rechargeRunebook:
findItem %recallScrolls C_ , %dropContainerId
if ( #findKind = -1 )
    pause ; Out of recall scrolls
if ( #findCol <> 0 )
{
    ignoreItem #findId
    goto rechargeRunebook
}
exevent drag #findId %maxRunebookCharges
wait 10
exevent dropC %runebookId
wait 10
findItem %recallScrolls C_ , #backPackId
set %recallScrollsUsed %recallScrollsUsed + ( %maxRunebookCharges - #findStack )
exevent drag #findId #findStack
wait 10
exevent dropC %dropContainerId
wait 10
return

; gosub openContainer [containerId]
sub openContainer
set %_containerId %1
_openContainer:
set #lObjectId %_containerId
event macro 17
set %_timeout #scnt + 10
_waitOpenContainer:
if ( %_timeout < #scnt )
    goto _openContainer
if ( #contId = %_containerId )
   return
goto _openContainer

sub updateTitle
gosub getElapsedTime
set %elapsedTime #result
setUoTitle Ultima Online - #charName ( , #shard , ) - Iron: %ironCollected Stone: %stoneCollected Tools: %miningToolsUsed Recall: %recallScrollsUsed Time: %elapsedTime
return

sub getElapsedTime
set %_days 0
set %_hours 0
set %_minutes 0
set %_seconds #scnt - %start
while ( %_seconds >= 86400 )
{
    set %_days %_days + 1
    set %_seconds %_seconds - 86400
}
while ( %_seconds >= 3600 )
{
    set %_hours %_hours + 1
    set %_seconds %_seconds - 3600
}
while ( %_seconds >= 60 )
{
    set %_minutes %_minutes + 1
    set %_seconds %_seconds - 60
}

return %_days , d , %_hours , h , %_minutes , m , %_seconds , s
