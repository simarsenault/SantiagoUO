; Configuration
set %mines 10                    ; Number of mines in runebook (slot 2-16)
set %runebookId PIWYJMD          ; Runebook ID (first rune = drop location, 2-16th runes = mines)
if ( #charName = Stella )
{
    set %mines 10
    set %runebookId PIWYJMD
}
if ( #charName = Bentley )
{
    set %mines 9
    set %runebookId BOYBKMD
}
set %dropContainerId XWNAKMD     ; Work container (drop ingots/ores, contains recall scroll, pickaxes and tinker tool)
set %smeltWeight 350             ; Weight needed to go smelt
set %bankWeight 175              ; Weight needed after smelting to go bank
set %percentSwitchMine 60        ; Percentage at which it will trigger a mine switch after banking
set %smelt1x1 #false             ; Smelt ores one by one (#true/#false)
set %miningToolsRecharge 4       ; Amount of mining tools to have before going back mining (1 if you got newbied pickaxe)
set %rechargeRunebook #true      ; Recharge runebook (#true/#false)
set %maxRunebookCharges 10       ; Maximum charges in runebook
set %miningToolsToCraft 10       ; When out of pickaxes, amount to craft
set %mineArea 40                 ; Area to scan for minable tiles around forge
set %maximumPathfindDistance 17  ; Maximum distance to pathFind
set %smartPathFindTimeout 60     ; Maximum time allowed per smart pathfind (seconds)
set %pathfindTimeout 10          ; Maximum time allowed per pathfind (seconds)
set %miningTimeout 8             ; Maximum time allowed per mining stroke (seconds)
set %nodeMaximumTries 3          ; Maximum failed attempts per mining node before going to the next
set %deathTime 6000              ; Time to wait before resurrecting (20 = 1 second)

; Constants
set %tinkeringTools GTL
set %ironRequiredMiningTool 8
set %miningTools NPF_QPF
set %forge JBG
set %oresStacks DWJ_EWJ_GWJ
set %oresOne TVJ
set %ores %oresStacks , _ , %oresOne
set %ironIngots RMK
set %ingots %ironIngots , _NMK_XMK_TMK
set %oresIngots %ores , _ , %ingots
set %recallScrolls WTL
set %pathFindMineSpotTolerance 0
set %pathFindForgeTolerance 1

; Stats
set %ironCollected 0
set %stoneCollected 0
set %miningToolsUsed 0
set %recallScrollsUsed 0
set %deaths 0

; Do not change
set %mustBank #false
set %mineChanged #true
set %currentMine 1
set %start #scnt

set #LPC 1000
tile init

miningLoop:
set %mustBank #false
if ( %mineChanged = #false )
    goto _miningLoop
gosub resetForge
gosub resetSpots
set %mineChanged #false
for %miningLoop 1 %spots
{
    _miningLoop:
    set %mineX %spotX . %miningLoop
    set %mineY %spotY . %miningLoop
    set %mineZ %spotZ . %miningLoop

    gosub hasUnminedTileAround %mineX %mineY
    if ( #result = #true )
    {
        gosub smartPathFind %mineX %mineY %mineZ %pathFindMineSpotTolerance
        if ( #result = #true )
        {
            set %_startX %mineX - 1
            set %_startY %mineY - 1
            set %_endX %mineX + 1
            set %_endY %mineY + 1

            for %_loopX %_startX %_endX
            {
                for %_loopY %_startY %_endY
                {
                    gosub updateStatisticsMenu

                    if ( %_loopX = %mineX && %_loopY = %mineY )
                        continue

                    gosub isLocationMineable %_loopX %_loopY
                    if ( #result = #true )
                    {
                        set %_mineLocation %1 , _ , %2
                        set %_mineLocationTileType %spotTileType . %_mineLocation
                        set %_mineLocationZ %spotZ . %_mineLocation

                        gosub mine %_loopX %_loopY %_mineLocationZ %_mineLocationTileType

                        set %spotMined . %_mineLocation #true
                    }
                    
                    if ( #charGhost = yes )
                        goto skipMine

                    if ( %mustBank = #true )
                    {
                        set %percentDone %miningLoop * 100 / %spots
                        if ( %percentDone >= %percentSwitchMine )
                            goto switchMine
                        goto skipMine
                    }
                }
            }
        }
    }
}
switchMine:
set %mineChanged #true
set %currentMine %currentMine + 1
if ( %currentMine > %mines )
    set %currentMine 1
skipMine:
gosub smartPathFind %forgeX %forgeY %forgeZ %pathFindForgeTolerance
gosub smelt
if ( #charGhost = yes )
{
    wait %deathTime
    set %deaths %deaths + 1
    gosub resurrect
}
gosub bank
wait 20
goto miningLoop

sub resetForge
findItem %forge G_3
if ( #findKind = -1 )
    pause
set %forgeX #findX
set %forgeY #findY
set %forgeZ #findZ
return

sub resetSpots
set %startX %forgeX - %mineArea
set %startY %forgeY - %mineArea
set %endX %forgeX + %mineArea
set %endY %forgeY + %mineArea
set %_startY %startY
set %_endY %endY
set %spots 0
for %_loopX %startX %endX
{
    for %_loopY %_startY %_endY
    {
        tile cnt %_loopX %_loopY
        set %_skipSpot #false
        set %_spotAdded #false

        for %tile 1 #tileCnt
        {
            tile get %_loopX %_loopY %tile

            if ( #tileName in stalagmites_flowstone_cave_wall )
                set %_skipSpot #true

            if ( #tileType >= 1339 && #tileType <= 1359 )
            {
                set %spots %spots + 1
                set %spotX . %spots %_loopX
                set %spotY . %spots %_loopY
                set %spotZ . %spots #tileZ
                set %spotMined . %_loopX , _ , %_loopY #false
                set %spotTileType . %_loopX , _ , %_loopY #tileType
                set %spotZ . %_loopX , _ , %_loopY #tileZ
                set %_spotAdded #true
            }
        }

        if ( %_skipSpot = #true && %_spotAdded = #true )
            set %spots %spots - 1
    }
}
return

; gosub hasUnminedTileAround locationX locationY
sub hasUnminedTileAround
set %_hasUnminedTileAroundLocationX %1
set %_hasUnminedTileAroundLocationY %2
set %_hasUnminedTileAroundStartX %_hasUnminedTileAroundLocationX - 1
set %_hasUnminedTileAroundStartY %_hasUnminedTileAroundLocationY - 1
set %_hasUnminedTileAroundEndX %_hasUnminedTileAroundLocationX + 1
set %_hasUnminedTileAroundEndY %_hasUnminedTileAroundLocationY + 1

for %_hasUnminedTileAroundLoopX %_hasUnminedTileAroundStartX %_hasUnminedTileAroundEndX
{
    for %_hasUnminedTileAroundLoopY %_hasUnminedTileAroundStartY %_hasUnminedTileAroundEndY
    {
        if ( %_hasUnminedTileAroundLoopX = %_hasUnminedTileAroundLocationX && %_hasUnminedTileAroundLoopY = %_hasUnminedTileAroundLocationY )
            continue ; can't mine under yourself

        gosub isLocationMineable %_hasUnminedTileAroundLoopX %_hasUnminedTileAroundLoopY
        if ( #result = #true )
            return #true
    }
}
return #false

; gosub isLocationMineable x y
sub isLocationMineable
set %_isLocationMineableX_Y %1 , _ , %2
set %_isLocationMineableIsMined %spotMined . %_isLocationMineableX_Y
if ( %_isLocationMineableIsMined = #false )
    return #true
return #false ; this case handle N/A

; gosub smartPathFind [x] [y] [z] [tolerance]
sub smartPathFind
set %_smartPathFindX %1
set %_smartPathFindY %2
set %_smartPathFindZ %3
set %_smartPathFindTolerance %4
set %_smartPathFindTimeout #scnt + %smartPathFindTimeout
gosub isCharPosWithinTolerance %_smartPathFindX %_smartPathFindY %maximumPathfindDistance
while ( #result = #false )
{
    if ( %_smartPathFindTimeout < #scnt )
        break

    set %_bestCandidateX #charPosX
    set %_bestCandidateY #charPosY
    set %_bestCandidateZ #charPosZ

    for %_candidate 1 %spots
    {
        set %_candidateX %spotX . %_candidate
        set %_candidateY %spotY . %_candidate
        set %_candidateZ %spotZ . %_candidate

        gosub isBetterSmartPathFindCandidate %_candidateX %_candidateY %_smartPathFindX %_smartPathFindY %_bestCandidateX %_bestCandidateY %maximumPathfindDistance
        if ( #result = #true )
        {
            set %_bestCandidateX %_candidateX
            set %_bestCandidateY %_candidateY
            set %_bestCandidateZ %_candidateZ
        }
    }

    if ( %_bestCandidateX = #charPosX && %_bestCandidateY = #charPosY )
        return #false ; no candidate found

    gosub pathFind %_bestCandidateX %_bestCandidateY %_bestCandidateZ %_smartPathFindTolerance
    if ( #result = #false )
        return #false
    gosub isCharPosWithinTolerance %_smartPathFindX %_smartPathFindY %maximumPathfindDistance
}
gosub pathFind %_smartPathFindX %_smartPathFindY %_smartPathFindZ %_smartPathFindTolerance %_smartPathFindTimeout
return #result

; gosub isBetterSmartPathFindCandidate candidateX candidateY destinationX destinationY bestCandidateX bestCandidateY maxDistance
sub isBetterSmartPathFindCandidate
set %_distanceToCandidateX #charPosX - %1 abs
set %_distanceToCandidateY #charPosY - %2 abs

if ( %_distanceToCandidateX > %7 || %_distanceToCandidateY > %7 )
    return #false ; Candidate is out of reach

set %_distanceCandidateToDestinationX %1 - %3 abs
set %_distanceCandidateToDestinationY %2 - %4 abs
set %_distanceCandidateToDestination %_distanceCandidateToDestinationX + %_distanceCandidateToDestinationY

set %_distanceBestCandidateToDestinationX %5 - %3 abs
set %_distanceBestCandidateToDestinationY %6 - %4 abs
set %_distanceBestCandidateToDestination %_distanceBestCandidateToDestinationX + %_distanceBestCandidateToDestinationY

if ( %_distanceCandidateToDestination < %_distanceBestCandidateToDestination )
    return #true ; Candidate is in reach and nearer to wanted destination

return #false ; Candidate is in reach, but farer to wanted destination

; gosub pathfind [x] [y] [z] [tolerance]
sub pathfind
set %_pathFindX %1
set %_pathFindY %2
set %_pathFindZ %3
set %_pathFindTolerance %4
set %_pathfindMoved #false
set %_timeout #scnt + %pathfindTimeout
set %_journal #jIndex + 1
gosub isCharPosWithinTolerance %_pathFindX %_pathFindY %_pathFindTolerance
if ( #result = #true )
{
    if ( %_pathfindMoved = #true )
        event pathfind 0 0 0
    return #true
}
event pathfind %_pathFindX %_pathFindY %_pathFindZ
_pathfind:
gosub isCharPosWithinTolerance %_pathFindX %_pathFindY %_pathFindTolerance
if ( #result = #true )
{
    if ( %_pathfindMoved = #true )
        event pathfind 0 0 0
    return #true
}
if ( %_timeout < #scnt )
{
    if ( %_pathfindMoved = #true )
        event pathfind 0 0 0
    return #false
}
if ( %_journal <= #jIndex )
{
    scanJournal %_journal
    if ( get_there in #journal )
        return #false
    if ( pathfinding in #journal )
        set %_pathfindMoved #true
    set %_journal %_journal + 1
}
goto _pathfind

sub isCharPosWithinTolerance
set %_x %1
set %_y %2
set %_dist %3
set %_distX #charPosX - %_x abs
set %_distY #charPosY - %_y abs
if ( %_distX <= %_dist && %_distY <= %_dist )
    return #true
return #false

sub mine
set %_mineX %1
set %_mineY %2
set %_mineZ %3
set %_mineTile %4
set %_nodeTries 0
_mine:
set %_nodeTries %_nodeTries + 1
if ( %_nodeTries > %nodeMaximumTries )
    return
if ( #weight >= %smeltWeight )
{
    gosub smartPathFind %forgeX %forgeY %forgeZ %pathFindForgeTolerance
    gosub smelt
    wait 10

    if ( #weight >= %bankWeight )
    {
        set %mustBank #true

        return
    }
    gosub smartPathFind %_mineX %_mineY %_mineZ %pathFindMineSpotTolerance
}
findItem %miningTools C_
if ( #findKind = -1 )
{
    set %mustBank #true

    return
}
set #lObjectId #findId
set #lTargetX %_mineX
set #lTargetY %_mineY
set #lTargetZ %_mineZ
set #lTargetTile %_mineTile
set #lTargetKind 3
set %_journal #jIndex
event macro 17
target
event macro 22
set %_mine #scnt + %miningTimeout
_mineJournal:
if ( %_mine < #scnt )
    return
if ( #jIndex <= %_journal )
    goto _mineJournal
set %_journal %_journal + 1
scanJournal %_journal
if ( there_is_nothing_here in #journal )
    return
if ( you_loosen_some_rocks in #journal )
    goto _mine
if ( you_put in #journal )
{
    set %_nodeTries 0
    goto _mine
}
if ( you_cannot_mine in #journal )
    return
if ( you_have_no_line in #journal )
    return
if ( try_mining_elsewhere in #journal )
    return
if ( that_is_too_far in #journal )
    return
goto _mineJournal

sub smelt
if ( %smelt1x1 = #true )
    gosub separateOres
ignoreItem reset
_smelt:
findItem %ores C_ , #backPackId
if ( #findKind = -1 )
    return
set #lObjectId #findId
set %_journal #jIndex + 1
event macro 17
for %_loop %_journal #jIndex
{
    scanJournal %_loop
    if ( you_need_atleast in #journal )
        ignoreItem #findId
    if ( you_must_be_near in #journal )
        ignoreItem #findId
}
goto _smelt

sub separateOres
ignoreitem reset
_seperateOres:
finditem %oresStacks C_ , #backpackId
if ( #findKind = -1 )
    return
ignoreitem #findId
exevent drag #findId 1
wait 5
exevent dropc #backpackid 80 80
wait 5
goto _seperateOres

; gosub recall [rune]
sub recall
set %_rune %1
if ( %_rune <= 8 )
{
    set %_runeX 85
    set %_runeY 115 + ( ( %_rune - 1 ) * 14 )
}
else
{
    set %_runeX 245
    set %_runeY 115 + ( ( %_rune - 9 ) * 14 )
}
set %_charPosX #charPosX
set %_charPosY #charPosY
_openRunebook:
set %_openRunebook #scnt + 10
set #lObjectId %runebookId
event macro 17
_waitOpenRunebook:
if ( %_openRunebook < #scnt )
   goto _openRunebook
if ( #contSizeX <> 352 || #contSizeY <> 226 )
   goto _waitOpenRunebook
set %_recall #scnt + 10
click %_runeX %_runeY
_waitRecall:
if ( %_recall < #scnt )
    goto _openRunebook
if ( #charPosX <> %_charPosX || #charPosY <> %_charPosY )
    return
goto _waitRecall

sub bank
gosub recall 1
gosub dropIngotsOres
gosub restockMiningTools
if ( %rechargeRunebook = #true )
    gosub rechargeRunebook
set %mineTemp %currentMine + 1
gosub recall %mineTemp
return

sub dropIngotsOres
ignoreitem reset
_dropIngotsOres:
findItem %oresIngots C_ , #backpackId
if ( #findKind = -1 )
    return
if ( #findType in %ingots && #findCol = 0 )
    set %ironCollected %ironCollected + #findStack
if ( #findType in %ingots && #findCol = 2103 )
    set %stoneCollected %stoneCollected + #findStack
ignoreitem #findid
exevent drag #findId #findStack
wait 10
exevent dropc %dropContainerId
wait 10
goto _dropIngotsOres

sub restockMiningTools
_restockMiningTools:
findItem %miningTools C_ , #backPackId
if ( #findCnt >= %miningToolsRecharge )
    return
set %miningToolsToGrab %miningToolsRecharge - #findCnt
gosub openContainer %dropContainerId
findItem %miningTools C_ , %dropContainerId
if ( #findCnt < %miningToolsToGrab )
{
    gosub craftMiningTools
    goto _restockMiningTools
}
for %_loop 1 %miningToolsToGrab
{
    findItem %miningTools C_ , %dropContainerId
    exevent drag #findId
    wait 10
    exevent dropC #backPackId
    wait 10
}
set %miningToolsUsed %miningToolsUsed + %miningToolsToGrab
return

sub craftMiningTools
findItem %tinkeringTools C_ , %dropContainerId
if ( #findKind = -1 )
    pause
exevent drag #findId 1
wait 10
exevent dropC #backPackId
wait 10
ignoreItem reset
_findIronIngots:
findItem %ironIngots C_ , %dropContainerId
if ( #findKind = -1 )
    pause
if ( #findCol <> 0 )
{
    ignoreItem #findId
    goto _findIronIngots
}
set %_ironAmount %ironRequiredMiningTool * %miningToolsToCraft
exevent drag #findId %_ironAmount
wait 10
exevent dropC #backPackId
wait 10
_craftMiningTool:
findItem %ingots C_ , #backPackId
if ( #findKind = -1 || #findStack < %ironRequiredMiningTool )
    goto _dropTinkeringTools
msg $,waitmenu 'Tinkering' 'Tools' 'Tools' 'pickaxe'$
findItem %tinkeringTools C_ , #backPackId
set #lObjectId #findId
event macro 17
wait 80
goto _craftMiningTool
_dropTinkeringTools:
findItem %tinkeringTools C_ , #backPackId
exevent drag #findId 1
wait 10
exevent dropC %dropContainerId
wait 10
_dropMiningTools:
findItem %miningTools C_ , #backPackId
if ( #findKind = -1 )
    return
exevent drag #findId 1
wait 10
exevent dropC %dropContainerId 50 50
wait 10
goto _dropMiningTools

sub rechargeRunebook
ignoreItem reset
gosub openContainer %dropContainerId
_rechargeRunebook:
findItem %recallScrolls C_ , %dropContainerId
if ( #findKind = -1 )
    pause ; Out of recall scrolls
if ( #findCol <> 0 )
{
    ignoreItem #findId
    goto rechargeRunebook
}
exevent drag #findId %maxRunebookCharges
wait 10
exevent dropC %runebookId
wait 10
findItem %recallScrolls C_ , #backPackId
set %recallScrollsUsed %recallScrollsUsed + ( %maxRunebookCharges - #findStack )
exevent drag #findId #findStack
wait 10
exevent dropC %dropContainerId
wait 10
return

; gosub openContainer [containerId]
sub openContainer
set %_containerId %1
_openContainer:
set #lObjectId %_containerId
event macro 17
set %_timeout #scnt + 10
_waitOpenContainer:
if ( %_timeout < #scnt )
    goto _openContainer
if ( #contId = %_containerId )
   return
goto _openContainer

sub resurrect
set %_resurrectX #charPosX
set %_resurrectY #charPosY
_resurrect:
msg $home home home$
wait 10
if ( #charPosX = %_resurrectX || #charPosY = %_resurrectY )
    goto _resurrect
gosub pathfind 5182 1250 0 1
gosub pathfind 5182 1237 0 1
gosub pathfind 5182 1228 10 0
gosub pathfind 5182 1223 40 1
ignoreItem reset
_clickResurrectionStone:
findItem HTG G_1
if ( #findKind = -1 )
    pause
if ( #findCol <> 66 )
{
    ignoreItem #findId
    goto _clickResurrectionStone
}
ignoreItem reset
set #lObjectId #findId
event macro 17
gosub waitGump 380 150
if ( #result = #false )
    goto _clickResurrectionStone
click 72 100
wait 120
if ( #charGhost = yes )
    goto _clickResurrectionStone
event macro 8 1 ; open paperdoll
event macro 8 2 ; open status
event macro 8 7 ; open backpack
wait 20
move 5194 1229 0 10s
return

; gosub waitGump width height
sub waitGump
set %_waitGumpWidth %1
set %_waitGumpHeight %2
set %_waitGumpTimeout #scnt + 5
_waitGump:
if ( %_waitGumpTimeout < #scnt )
    return #false
if ( #contSizeX = %_waitGumpWidth && #contSizeY = %_waitGumpHeight )
    return #true
goto _waitGump

sub getElapsedTime
set %_days 0
set %_hours 0
set %_minutes 0
set %_seconds #scnt - %start
while ( %_seconds >= 86400 )
{
    set %_days %_days + 1
    set %_seconds %_seconds - 86400
}
while ( %_seconds >= 3600 )
{
    set %_hours %_hours + 1
    set %_seconds %_seconds - 3600
}
while ( %_seconds >= 60 )
{
    set %_minutes %_minutes + 1
    set %_seconds %_seconds - 60
}

return %_days , d , #spc ,  %_hours , h , #spc ,  %_minutes , m , #spc , %_seconds , s

sub updateStatisticsMenu
menu clear
menu window title Rukk's Mining Script
menu window color black
menu window size 500 270
menu font bgcolor black
menu font color lime
menu font style b
menu font size 14
menu text lblTitle 150 5 Rukk's Mining Script

menu font color white
menu font style b
menu font size 12
menu text lblCharName 10 40 Character:
menu text lblDeaths 300 40 Deaths:
menu text lblCurrentMine 10 60 Current mine:
menu text lblTotalMines 300 60 Total mines:
menu text lblCurrentMineProgress 10 80 Current mine progress:
menu text lblPickaxes 300 80 Pickaxes:
menu text lblRecallScrolls 10 100 Recall scrolls:
menu text lblEstimatedNetProfit 300 100 Est. Net Profit:
menu text lblRunTime 10 120 Run time:

menu text lblIron 10 160 Iron:
menu text lblStone 130 160 Stone:
menu text lblCopper 250 160 Copper:
menu text lblAgapite 370 160 Agapite:
menu text lblSilver 10 180 Silver:
menu text lblShadow 130 180 Shadow:
menu text lblGold 250 180 Gold:
menu text lblRose 370 180 Rose:
menu text lblValorite 10 200 Valorite:
menu text lblVerite 130 200 Verite:
menu text lblMytheril 250 200 Mytheril:
menu text lblBloodrock 370 200 Bloodrock:
menu text lblBlackrock 10 220 Blackrock:
menu text lblPlatinum 130 220 Platinum:
menu text lblCarbonPolymer 250 220 Carbon:
menu text lblKevlar 370 220 Kevlar:
menu text lblDelta 10 240 Delta:
menu text lblLiquid 130 240 Liquid:
menu text lblRagnarok 250 240 Ragnarok:
menu text lblTotal 370 240 TOTAL:

menu font style
menu font color red
menu text lblCharNameValue 95 40 #charName
menu text lblDeathsValue 365 40 %deaths
menu text lblCurrentMineValue 120 60 %currentMine
menu text lblTotalMinesValue 395 60 %mines
set %_mineProgress %miningLoop * 100 / %spots
menu text lblCurrentMineProgressValue 190 80 %miningLoop , / , %spots , #spc , ( , %_mineProgress , % , )
menu text lblPickaxesValue 380 80 %miningToolsUsed
menu text lblRecallScrollsValue 120 100 %recallScrollsUsed
menu text lblEstimatedNetProfitValue 415 100 N/A
gosub getElapsedTime
menu text lblRunTimeValue 90 120 #result

menu text lblIronValue 50 160 %ironCollected
menu text lblStoneValue 185 160 %stoneCollected
menu text lblCopperValue 315 160 N/A
menu text lblAgapiteValue 435 160 N/A
menu text lblSilverValue 62 180 N/A
menu text lblShadowValue 200 180 N/A
menu text lblGoldValue 295 180 N/A
menu text lblRoseValue 420 180 N/A
menu text lblValoriteValue 75 200 N/A
menu text lblVeriteValue 180 200 N/A
menu text lblMytherilValue 320 200 N/A
menu text lblBloodrockValue 460 200 N/A
menu text lblBlackrockValue 95 220 N/A
menu text lblPlatinumValue 205 220 N/A
menu text lblCarbonPolymerValue 315 220 N/A
menu text lblKevlarValue 428 220 N/A
menu text lblDeltaValue 60 240 N/A
menu text lblLiquidValue 185 240 N/A
menu text lblRagnarokValue 332 240 N/A
set %_totalIngotsOres %ironCollected + %stoneCollected
menu text lblTotalValue 430 240 %_totalIngotsOres
menu show
return
